import binascii

from base64 import urlsafe_b64decode, urlsafe_b64encode
from datetime import datetime
from typing import Annotated

from pydantic import AfterValidator, BaseModel, Field

from settings import settings

def _validate_public_key(value: str) -> str:
    try:
        raw_bytes = urlsafe_b64decode(value)
        if len(raw_bytes) != 32:
            raise ValueError('Value must have an unencoded length of 32 bytes')
        return urlsafe_b64encode(raw_bytes).decode()
    except binascii.Error:
        raise ValueError('Value is not valid Base64')

def _validate_message(value: str) -> str:
    try:
        message = urlsafe_b64encode(urlsafe_b64decode(value)).decode()
        if len(message) > settings.max_ciphertext_length:
            raise ValueError((
                f'Message is too large. The maximum ciphertext length for a '
                f'single request is {settings.max_ciphertext_length} bytes. '
                f'This corresponds to a maximum plaintext length of '
                f'{settings.effective_max_plaintext_length} bytes.'
            ))
        return message
    except binascii.Error:
        raise ValueError('Value is not valid Base64')

def _validate_signature(value: str) -> str:
    try:
        raw_bytes = urlsafe_b64decode(value)
        if len(raw_bytes) != 64:
            raise ValueError('Value must have an unencoded length of 64 bytes')
        return urlsafe_b64encode(raw_bytes).decode()
    except binascii.Error:
        raise ValueError('Value is not valid Base64')

type _PublicKey = Annotated[
    str,
    AfterValidator(_validate_public_key),
]

type _Message = Annotated[
    str,
    AfterValidator(_validate_message),
]

type _Signature = Annotated[
    str,
    AfterValidator(_validate_signature),
]

class _BaseRequestModel(BaseModel):
    public_key: Annotated[
        _PublicKey,
        Field(
            description=(
                'The Base64-encoding of a 32-byte public key owned by the '
                'user.'
            ),
            examples=['PBiNdoolrxt0FdTiAA2wSbG4eoKClTJEP2JoVFGrWU0='],
        ),
    ]

class _RetrievalFilterModel(BaseModel):
    sender_keys: Annotated[
        list[str] | None,
        Field(
            description=(
                'An optional list of Base64-encoded 32-byte public keys. '
                'If provided, only data sent by users with these keys will be '
                'retrieved.'
            ),
            default=None,
            examples=[
                [
                    'XuPFHG1T6MfukWZSDEjLCAqFFh9EAUWUYRZow_1FJ6c=',
                    '1pkkOi6TX-o8RTU4NAZXT6SRcaUu6DFKIg7eMB9ujD8=',
                    'Vx_ZU7jYWd-csCdgK3gRZRRBmTdkV3VCV-clcbzxaBg=',
                ]
            ],
        ),
    ]
    min_datetime: Annotated[
        datetime | None,
        Field(
            description=(
                'An optional datetime that represents the earliest timestamp '
                'retrieved data should have. This is intended to avoid '
                'unneccessarily repeating retrievals.'
            ),
            default=None,
        ),
    ]

class PostExchangeKeyRequestModel(_BaseRequestModel):
    recipient_public_key: Annotated[
        _PublicKey,
        Field(
            description=(
                'The Base64-encoding of a 32-byte public key owned by the '
                'desired recipient of the key exchange.'
            ),
            examples=['TMkABteGZVYRjdbupBupB7nmiTmZ9C_JugYNw0Xsp7w='],
        ),
        
    ]
    exchange_key: Annotated[
        _PublicKey,
        Field(
            description=('The Base64-encoding of a 32-byte exchange key.'),
            examples=['bR-PDpKYqMOv-rxKWBBoEbI5PPyXyIyKXAh6XmMp7TI='],
        ),
    ]
    signature: Annotated[
        _Signature,
        Field(
            description=(
                'The Base64-encoding of a signature generated by signing the '
                'raw bytes of the transmitted exchange key with the private '
                'key corresponding to the sender\'s public key.'
            ),
            examples=[
                (
                    'DF2AqxtW6uFQQh0Z2XeMB9MkM12od126WjKGpTGbynhh8_zAkuFHg_jT_'
                    '7b3vy41PO2n5dJZykM8PTqj8di7AQ=='
                )
            ]
        ),
    ]

class PostMessageRequestModel(_BaseRequestModel):
    recipient_public_key: Annotated[
        _PublicKey,
        Field(
            description=(
                'The Base64-encoding of a 32-byte public key owned by the '
                'desired recipient of the encrypted message.'
            ),
            examples=['oiAftUmc3OcUWUzkLGmmttv0F9vjwjC0gX6p9FQvZC0='],
        ),
    ]
    encrypted_text: Annotated[
        _Message,
        Field(
            description=(
                'A Base64-encoding of the encrypted message, generated using '
                'a shared secret encryption key prior to transmission. This '
                'should typically be the output of a Fernet encryption, which '
                'is already Base64-encoded.'
            ),
            examples=[
                (
                    'gAAAAABoQtwrJw3saJMxOIaMBAQURKulgp3ch8wK2bnE4ynBk7vEd8_VO'
                    'uTZqc07MFo3ZJv2qxGJ534MYxeLLsj0B6uvpjPdpAWX8R_ABQz3gWOPM3'
                    'LwSSAYR7CeYRhUwVeHI5GgZlms'
                ),
            ]
        ),
    ]
    signature: Annotated[
        _Signature,
        Field(
            description=(
                'The Base64-encoding of a signature generated by signing the '
                'encrypted message. The signature should typically be '
                'generated directly from the output of a Fernet encryption.'
            ),
            examples=[
                (
                    'dAQh05FB_982yP9EixN_1nCwKKj1UpbIYLMFzqXIJG6_jNMU2gMQVWizn'
                    'd0FwGViIpZ9udDMmyti7cNDa31oBg=='
                ),
            ]
        ),
    ]

class RetrievalRequestModel(_BaseRequestModel, _RetrievalFilterModel):
    pass
